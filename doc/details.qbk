[/ -*- compile-command: "bjam" -*-; auto-fill-mode: t /]

[section Advanced topics]

[section Virtual and multiple inheritance]


All forms of virtual and multiple inheritance are supported, sometimes
at the cost of a performance cost or some extra work on your part.

[h3 Virtual inheritance]

Virtual inheritance is not a problem, however, a call to a
multi-method that involves an argument that is virtually inherited in
the selected specialization will incur the cost of a
`dynamic_cast`. For example:

``
struct X { ... };
struct A : X { ... };
struct B : virtual X { ... };

MULTI_METHOD(foo, void, const virtual_<X&>, const virtual_<X&>);

BEGIN_SPECIALIZATION(foo, void, const X&, const X&)
  // ...
END_SPECIALIZATION;

BEGIN_SPECIALIZATION(foo, void, const A&, const B&)
  // ...
END_SPECIALIZATION;

foo(X(), X()); // 1
foo(A(), B()); // 2
``

Here the first call to `foo()` does not necessitate a cast: both
arguments are `X` objects.

As for the second call, the first argument needs to be converted to a
`A` before calling the specialization. That can be achieved with a
`static_cast`, an operation that has a zero runtime cost. The second
argument, however, requires a cast from virtual base class `X` to
`B` - performed via a costly `dynamic_cast`.

[h3 Multiple `selector` sub-objects]

It may happen that class `selector` is repeatedly inherited, even in
inheritance graphs that don't involve repeated inheritance by
themselves. For example:

``
struct X : selector { ... };
struct Y : selector { ... };
struct XY : X, Y { ... };

MULTI_METHOD(foo, void, const virtual_<X>&);
MULTI_METHOD(bar, void, const virtual_<XY>&);

foo(XY()); // 1
bar(XY()); // 2
``

The first call poses no problem. `foo` takes a `X` object, which
contains a single `selector` sub-object.

The second call is more difficult: `bar` takes a `XY` object that
contains /two/ `selector` sub-object. Truth is, it does not matter
which `selector` it uses: they contain the same
information. Nonetheless, you must tell C++ which `selector` to
chose.

Moreover, in the cooperating model, it is the responsibility of the
classes to initialize the `selector` objects.

This is achieved by using special forms of the `MM_CLASS` and
`MM_INIT` macros:

``
struct XY : X, Y {
  MM_CLASS_MULTI(XY, X, Y);

  XY() {
    MM_INIT_MULTI(X);
    MM_INIT_MULTI(Y);
  }
};
``

[h3 Repeated inheritance]



[endsect]

[section No macros please]
[endsect]

[section Dynamic loading]
[endsect]

[section Performance]
[endsect]

[endsect]