[/ -*- compile-command: "bjam" -*-; auto-fill-mode: t /]

[section Reference]

[def __name__ [~name]]
[def __return_type__ [~return_type]]
[def __args__ [~args]]
[def __arg__ [~arg]]
[def __class__ [~class]]
[def __base__ [~base]]
[def __bases__ [~bases]]
[def __class_template__ [~class_template]]
[def __specialization__ [~specialization]]
[def __mm__ [~multi_method]]

[import reference_examples.cpp]

[section Registering classes]

[section selector]

[h3 Synopsis]

class [~MyClass] : public selector { ... };

[h3 Description]

Achieve optimal performance by lending space for a pointer to the dispatcher.

Inherit from class `selector` to achieve best performance in
multi-method dispatch. It contains one name - `_mm_init_class` - which
is an implementation detail.

[endsect]

[section:mm_class MM_CLASS]

[h3 Synopsis]

MM_CLASS(__class__, __bases__...)

[h3 Description]

Registers a class for efficient multi-method dispatch.

Macro `MM_CLASS` must be called inside the definition of __class__. The
subsequent arguments __bases__ consist in the (possibly empty) list 
of base classes that the dispatcher must take into account. __class__
must derive (directly or indirectly) from `multimethods::selector`.

Three items are introduced in the class' scope, all of which
are implementation details: `mm_base_list`, `mm_this_type` and
`_mm_init_class`.

[h3 Example]
``
struct animal : multimethods::selector {
  MM_CLASS(animal);
};

struct female : virtual animal {
  MM_CLASS(female, animal);
};

struct horse : virtual animal {
  MM_CLASS(horse, animal);
};

struct mare : horse, female {
  MM_CLASS(mare, horse, female);
};
``

[endsect]

[section MM_CLASS_MULTI]

[h3 Synopsis]

MM_CLASS_MULTI(__class__, __bases__...)

[h3 Description]

Same as [link multi_methods.reference.registering_classes.mm_class MM_CLASS], to be used
in presence of *repeated* inheritance of class `selector`.

`MM_CLASS_MULTI` should not be used if __class__ inherits (virtually)
the same `selector` sub-object via different inheritance paths.

[h3 Examples]

``

struct Satellite : selector {
  MM_CLASS(Satellite);
};

struct Displayable : selector {
  MM_CLASS(Displayable);
};

struct DisplayableSatellite {
  MM_CLASS_MULTI(DisplayableSatellite, Satellite, Displayable);
};

``

[endsect]

[section MM_FOREIGN_CLASS]

[h3 Synopsis]

MM_FOREIGN_CLASS(__class__, __bases__...)

[h3 Description]

Registers a class for multi-method dispatch, non-intrusively.

Macro `MM_FOREIGN_CLASS` must be called outside the definition of
__class__, in an implementation file. __class__ must be polymorphic,
i.e. have at least one virtual function. The subsequent arguments __bases__
consist in the (possibly empty) list of base classes that the
dispatcher must take into account.

[h3 Examples]
``
struct animal {
  virtual ~animal();
};

struct female : virtual animal {
};

struct horse : virtual animal {
};

struct mare : horse, female {
};

// in .cpp file(s)
MM_FOREIGN_CLASS(animal);
MM_FOREIGN_CLASS(female, animal);
MM_FOREIGN_CLASS(horse, animal);
MM_FOREIGN_CLASS(mare, horse, female);
``
[endsect]

[section MM_CLASS_INIT]

[h3 Synopsis]

``
// in constructor
MM_CLASS_INIT();
``

[h3 Description]

Initialize the pointer to the multi-method offset table.

`MM_INIT()` must be called in each constructor of each class registered for fast dispatch. Even if a class does not otherwise need constructors (e.g. the generated default and copy constructors could suffice), they must be provided for the benefit of calling `MM_INIT()`.

[h3 Example]

``

matrix::matrix() {
  MM_INIT();
  // ...
}

matrix::matrix(const matrix& other) {
  MM_INIT();
  // ...
}

matrix::matrix(int rows, int cols) {
  MM_INIT();
  // ...
}

``

[endsect]

[section MM_CLASS_INIT_MULTI]

[h3 Synopsis]

``
// in constructor
MM_CLASS_INIT_MULTI();
``

[h3 Description]

Same as [link multi_methods.reference.registering_classes.mm_class_multi MM_CLASS_MULTI], to be used in presence of *repeated* inheritance of class `selector`.

[endsect]

[endsect]

[section Declaring multi-methods]

[section MULTI_METHOD]

[h3 Synopsis]
MULTI_METHOD(__name__, __return_type__, __args__...)

[h3 Description]

Declares a multi-method that takes __args__ as an argument list and
returns a __return_type__.

__args__ is an argument list, just like what is provided to an ordinary
function declaration. However, arguments marked with the `virtual_`
modifier are considered in the selection of the actual code to be
executed given the dynamic value passed in these positons.

Virtual arguments must have their type registered with the
MM_*CLASS family of macros. Virtual arguments, either of the intrusive
or foreign kinds, and ordinary function arguments can be freely
intermixed.

Multi-method declarations can appear in header files - __name__ is
defined as a `constexpr` function object.

__name__ must be unique in its scope. Overloading is not supported.

[endsect]

[h3 Examples]

A multimethod named `approve` that takes three virtual arguments and
returns a boolean:

``
MULTI_METHOD(approve, bool, const virtual_<expense>&, const virtual_<role>&, const virtual_<reason>&);
``

A `collide` multi-method that takes two virtual and one ordinary
argument and returns nothing:
``
MULTI_METHOD(collide, void, virtual_<object>&, virtual_<object>&, bool swapped);
``
[section virtual_]

[h3 Synopsis]
virtual_<__class__>

[h3 Description]

`virtual_` denotes virtual arguments in a multi-method declaration.

__class__ must be a class type registered via one of the `MM_*CLASS`
macros. It can appear only in multi-method argument lists to declare a
reference to an object, constant or not. In other words, `virtual_`
may be used only in the following manner:

    virtual_<SomeType>&
    const virtual_<SomeType>&

[endsect]

[section multi_method]

[h3 Synopsis]
``
template<template<typename Signature> Spec, typename __return_type__, typename __args__...>
struct multimethod; // declared but not defined

template<template<typename Signature> __class_template__, typename __return_type__, typename __args__...>
struct multimethod<__specialization__, __return_type__(__args__)> {
  __return_type__ operator ()(__args__...);
  static void specialize<__specialization__>();
};
``
[h3 Description]

Defines a multi-method.

Actual multi-methods are specializations of this template, defined
only for argument lists matching the second synopsis.

__class_template__ is a user-provided class template that allows for the
creations of different multi-methods with the same signature. The
template is then typically used to define specializations while
averting namespace pollution.

__args__ must contain at least one argument that includes the
`virtual_` marker. The markers are removed from the signature of
`operator ()`.

Multi-methods are stateless function objects. The data structures
implementing specialization registration and method dispatch reside in
static data members. Typically, a multi-method declaration/definition 
consists in a `constexpr` declaration of a specialization of
`multi_method`.

[h3 Example]

[ref_multi_method]

[endsect]

[endsect]

[section Specializing]

[section BEGIN_SPECIALIZATION / END_SPECIALIZATION ]

[h3 Synopsis]

BEGIN_SPECIALIZATION(__name__, __return_type__, __args__...) {
   /body/
} END_SPECIALIZATION;

[h3 Description]

Specializes multi-method __name__. The code between braces is the
specialization's implementation.

__name__ must be the name of a previously declared
multi-method. __return_type__ must be conbertible to the multi-method's
return type. __args__ must have the same length as the multi-method's
argument list. Each argument must be either the same as the
multi-method's argument in the same position, or if the multi-method
has marked the argument with `virtual_`, a reference to an object of a
compliant type.

[h3 Examples]

Three specializations for `MULTI_METHOD(approve, bool, const virtual_<expense>&, const virtual_<role>&, const virtual_<reason>&)`:

``
BEGIN_SPECIALIZATION(approve, bool, const expense&, const role&, const reason&) {
  return false;
} END_SPECIALIZATION;

BEGIN_SPECIALIZATION(approve, bool, const expense&, const ceo&, const reason&) {
  return true;
} END_SPECIALIZATION;

BEGIN_SPECIALIZATION(approve, bool, const cab&, const manager&, const business&) {
  return true;
} END_SPECIALIZATION;
``

Two specializations for `MULTI_METHOD(collide, void, virtual_<object>&, virtual_<object>&, bool swapped)`:

``
BEGIN_SPECIALIZATION(collide, void, object& a, object& b, bool swapped) {
  if (swapped) {
     // kaboom
  } else {
    return collide(b, a, true);
  }
} END_SPECIALIZATION;

BEGIN_SPECIALIZATION(collide, void, asteroid& a, asteroid& b, bool swapped) {
  // do nothing
} END_SPECIALIZATION;
``

[endsect]

[section multi_method::specialize]

[h3 Synopsis]

__mm__<__class_template__, __return_type__(__args__...)>::specialize<__specialization__>();

[h3 Description]

Adds a specialization to a multi-method.

__specialization__ must be a class with the following pubic members:

* `static __return_type__ body(__args__...);`

* `static __return_type__ (*next)(__args...);`

Typically, __specialization__ is a specialization of __class_template__.

[h3 Example]

After example from [link multi_methods.reference.registering_classes.multi_method]:
[ref_spec]
// in main() or in a static constructor:
[ref_spec_call]

[endsect]

[endsect]

[section Calling]

[section initialize]

[h3 Synopsis]

multimethods::initialize();

[h3 Description]

Computes or re-computes the data structures underlying multi-method
dispatch.

`initialize()` should be called after all the classes and
multi-methods have been declared and before calling any multi-method,
typically at the beginning of `main()`. If classes or multi-methods
are added or removed (e.g. because of dynamic loading or un-loading of
shared libraries), `intitialize()` must be called again.

Initialization is a fairly expensive process, which involves among
other things topologically sorting class hierarchies, assigning slots
to multi-methods and computing dispatch tables. `initialize()`
attempts to be conservative and re-compute only what needs be;
however, adding or removing a single class or multi-method
entails the re-examination of the entire class graph.

[h3 Examples]

``

int main() {
  multimethods::initialize();
  // ...
  dlopen(...); // dynamically load a shared object
  multimethods::initialize(); // if classes or methods were added
  // ...
}

``

[endsect]

[section multi_method::operator ()]

[h3 Synopsis]

__mm__(__args__...);

[h3 Description]

Calls a multi-method.

[h3 Example]

``
approve(plane(), ceo(), comfort());
``

[endsect]

[endsect]

[endsect]
